/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.18_02 from the
 * contents of XEvent.xs. Do not edit this file, edit XEvent.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "XEvent.xs"
/*
#    XEvent.pm - An extension to PERL to access XEvent structures.
#    Copyright (C) 1996-1997  Martin Bartlett
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <X11/X.h>
#include <X11/Xlib.h>

/*
 * This is a very simple Xsub!! It provides an extension to perl that
 * allows Perl programs read-only access to the XEvent structure. So.
 * how do they get hold of an XEvent to read? Well, they use ANOTHER
 * Perl extension that blesses pointers to XEvents into the XEventPtr
 * class. Such an extension would do that by supplying a TYPEMAP as 
 * follows:
 *
 *		XEvent *	T_PTROBJ
 *
 * and then returning XEvent pointers as appropriate to the perl program.
 * 
 * An extension that does this is the XForms extension. So, using these
 * two extensions the perl programmer can do some pretty reasonable 
 * XWindows application programming.
 *
 * So whats in this package. Well, quite simply, every method in this
 * package is named after a field in the XEvent structure. Now, anyone
 * who has seen that structure knows that it is, in fact, a union of 
 * a bunch of other structures, the only common field of which is the
 * first field, the type field.
 *
 * However, this package is written so that you don't have to know the 
 * REAL structure of the event you are interested in, you just have to
 * know the name of the field you are after. ALL XEVent fields are
 * catered for, even the wierd vector ones. ALL are returned as perl
 * scalars of various intuitively obvious types.
 *
 * For info on how to use the XEventPtr extension, see XEventPtr.pm
 *
 */

/*
 * Structure defining the layout of the contants list
 */
#define NUMCONS 87
typedef struct _const_value {
        const char * constr;
        const double conval;
} const_value;

/*
 * The constants list
 */
static const_value  constants[NUMCONS] = {

	{ "AnyModifier", AnyModifier },
	{ "Button1", Button1 },
	{ "Button1Mask", Button1Mask },
	{ "Button1MotionMask", Button1MotionMask },
	{ "Button2", Button2 },
	{ "Button2Mask", Button2Mask },
	{ "Button2MotionMask", Button2MotionMask },
	{ "Button3", Button3 },
	{ "Button3Mask", Button3Mask },
	{ "Button3MotionMask", Button3MotionMask },
	{ "Button4", Button4 },
	{ "Button4Mask", Button4Mask },
	{ "Button4MotionMask", Button4MotionMask },
	{ "Button5", Button5 },
	{ "Button5Mask", Button5Mask },
	{ "Button5MotionMask", Button5MotionMask },
	{ "ButtonMotionMask", ButtonMotionMask },
	{ "ButtonPress", ButtonPress },
	{ "ButtonPressMask", ButtonPressMask },
	{ "ButtonRelease", ButtonRelease },
	{ "ButtonReleaseMask", ButtonReleaseMask },
	{ "CirculateNotify", CirculateNotify },
	{ "CirculateRequest", CirculateRequest },
	{ "ClientMessage", ClientMessage },
	{ "ColormapChangeMask", ColormapChangeMask },
	{ "ColormapNotify", ColormapNotify },
	{ "ConfigureNotify", ConfigureNotify },
	{ "ConfigureRequest", ConfigureRequest },
	{ "ControlMapIndex", ControlMapIndex },
	{ "ControlMask", ControlMask },
	{ "CreateNotify", CreateNotify },
	{ "DestroyNotify", DestroyNotify },
	{ "EnterNotify", EnterNotify },
	{ "EnterWindowMask", EnterWindowMask },
	{ "Expose", Expose },
	{ "ExposureMask", ExposureMask },
	{ "FocusChangeMask", FocusChangeMask },
	{ "FocusIn", FocusIn },
	{ "FocusOut", FocusOut },
	{ "GraphicsExpose", GraphicsExpose },
	{ "GravityNotify", GravityNotify },
	{ "KeyPress", KeyPress },
	{ "KeyPressMask", KeyPressMask },
	{ "KeyRelease", KeyRelease },
	{ "KeyReleaseMask", KeyReleaseMask },
	{ "KeymapNotify", KeymapNotify },
	{ "KeymapStateMask", KeymapStateMask },
	{ "LASTEvent", LASTEvent },
	{ "LeaveNotify", LeaveNotify },
	{ "LeaveWindowMask", LeaveWindowMask },
	{ "LockMapIndex", LockMapIndex },
	{ "LockMask", LockMask },
	{ "MapNotify", MapNotify },
	{ "MapRequest", MapRequest },
	{ "MappingNotify", MappingNotify },
	{ "Mod1MapIndex", Mod1MapIndex },
	{ "Mod1Mask", Mod1Mask },
	{ "Mod2MapIndex", Mod2MapIndex },
	{ "Mod2Mask", Mod2Mask },
	{ "Mod3MapIndex", Mod3MapIndex },
	{ "Mod3Mask", Mod3Mask },
	{ "Mod4MapIndex", Mod4MapIndex },
	{ "Mod4Mask", Mod4Mask },
	{ "Mod5MapIndex", Mod5MapIndex },
	{ "Mod5Mask", Mod5Mask },
	{ "MotionNotify", MotionNotify },
	{ "NoEventMask", NoEventMask },
	{ "NoExpose", NoExpose },
	{ "OwnerGrabButtonMask", OwnerGrabButtonMask },
	{ "PointerMotionHintMask", PointerMotionHintMask },
	{ "PointerMotionMask", PointerMotionMask },
	{ "PropertyChangeMask", PropertyChangeMask },
	{ "PropertyNotify", PropertyNotify },
	{ "ReparentNotify", ReparentNotify },
	{ "ResizeRedirectMask", ResizeRedirectMask },
	{ "ResizeRequest", ResizeRequest },
	{ "SelectionClear", SelectionClear },
	{ "SelectionNotify", SelectionNotify },
	{ "SelectionRequest", SelectionRequest },
	{ "ShiftMapIndex", ShiftMapIndex },
	{ "ShiftMask", ShiftMask },
	{ "StructureNotifyMask", StructureNotifyMask },
	{ "SubstructureNotifyMask", SubstructureNotifyMask },
	{ "SubstructureRedirectMask", SubstructureRedirectMask },
	{ "UnmapNotify", UnmapNotify },
	{ "VisibilityChangeMask", VisibilityChangeMask },
	{ "VisibilityNotify", VisibilityNotify }
};

static double
constant(name, arg)
char *name;
int arg;
{
        int wrktop, wrkbot, wrkmid, i;

        errno = 0;
        wrktop = 0;
        wrkbot = NUMCONS-1;
        wrkmid = (NUMCONS/2)-1;
        while (wrktop < wrkmid && wrkbot > wrkmid) {
                i = strcmp(constants[wrkmid].constr, name);
                if (i == 0)
                        return constants[wrkmid].conval;
                else if (i < 0)
                        wrktop = wrkmid;
                else 
                        wrkbot = wrkmid;
                wrkmid = wrktop + ((wrkbot - wrktop) / 2);
        }

        /*
         * If we get here then we check the rest sequentially
         */

        while (wrktop <=  wrkbot) {
                if (strEQ(constants[wrktop].constr, name))
                        return constants[wrktop].conval;
                wrktop++;
        }

        errno = EINVAL;
        return 0;
}

/*
 * The obligitary not_here
 */
static int
not_here(s)
char *s;
{
    croak("%s not implemented on this architecture", s);
    return -1;
}



#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#line 224 "XEvent.c"

XS(XS_X11__XEvent_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__XEvent_constant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::XEvent::constant", "name, arg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	name = (char *)SvPV_nolen(ST(0));
	int	arg = (int)SvIV(ST(1));
	double	RETVAL;
	dXSTARG;

	RETVAL = constant(name, arg);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__XEvent_XKeycodeToKeysym); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__XEvent_XKeycodeToKeysym)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::XEvent::XKeycodeToKeysym", "display, keycode, index");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Display *	display = INT2PTR(Display *,SvIV(ST(0)));
	KeyCode	keycode = (unsigned char)SvUV(ST(1));
	int	index = (int)SvIV(ST(2));
	KeySym	RETVAL;
	dXSTARG;

	RETVAL = XKeycodeToKeysym(display, keycode, index);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__XEvent_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__XEvent_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::XEvent::new", "class");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	class = (char *)SvPV_nolen(ST(0));
	XEvent *	RETVAL;
#line 229 "XEvent.xs"
		{

			/*
			 * This is a test method that is NOT exported by the .pm
			 */

			XEvent *	newevent;

			printf("Creating a new event in %s!!\n", class);

			newevent = (XEvent *)malloc(sizeof(XEvent));

			newevent->xconfigure.type = ConfigureNotify;
			newevent->xconfigure.serial = 2;
			newevent->xconfigure.send_event = 3;
			newevent->xconfigure.display = (Display *)4;
			newevent->xconfigure.event = 5;
			newevent->xconfigure.window = 6;
			newevent->xconfigure.x = 7;
			newevent->xconfigure.y = 8;
			newevent->xconfigure.width = 9;
			newevent->xconfigure.height = 10;
			newevent->xconfigure.border_width = 11;
			newevent->xconfigure.above = 12;
			newevent->xconfigure.override_redirect = 13;

			RETVAL = newevent;
		}
#line 318 "XEvent.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "X11::XEvent", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__XEvent_display); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__XEvent_display)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::XEvent::display", "event");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	XEvent *	event;
	Display *	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "X11::XEvent")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    event = (XEvent *) tmp;
	}
	else
	    croak("event is not of type X11::XEvent");
#line 264 "XEvent.xs"
		{
			switch(event->type) {
				case  0:
					RETVAL = event->xerror.display;
					break;
				default:
					RETVAL = event->xany.display;
					break;
			}
		}
#line 359 "XEvent.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_X11__XEvent_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__XEvent_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", GvNAME(CvGV(cv)), "event");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	XEvent *	event;

	if (sv_isa(ST(0), "X11::XEvent")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    event = (XEvent *) tmp;
	}
	else
	    croak("event is not of type X11::XEvent");
#line 330 "XEvent.xs"
	{	
		ST(0) = sv_newmortal(); 
		switch (ix) {
		case 0:
			sv_setiv(ST(0), event->type);
			break;
		case 1:
			switch(event->type) {
				case  0:
					sv_setiv(ST(0), event->xerror.serial);
					break;
				default:
					sv_setiv(ST(0), event->xany.serial);
					break;
			}
			break;
		case 2:
			switch(event->type) {
				case  0:
					break;
				default:
					sv_setiv(ST(0), event->xany.send_event);
					break;
			}
			break;
		case 3:
			switch(event->type) {
				case  0:
					break;
				case  CreateNotify:
				case  DestroyNotify:
				case  UnmapNotify:
				case  MapNotify:
				case  MapRequest:
				case  ReparentNotify:
				case  ConfigureNotify:
				case  ConfigureRequest:
				case  GravityNotify:
				case  CirculateNotify:
				case  CirculateRequest:
					sv_setiv(ST(0), event->xcreatewindow.window);
					break;
				default:
					sv_setiv(ST(0), event->xany.window);
					break;
			}
			break;
		case 4:
			switch(event->type) {
				case  KeyPress:
				case  KeyRelease:
				case  ButtonPress:
				case  ButtonRelease:
				case  MotionNotify:
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xkey.root);
					break;
				default:
					break;
			}
			break;
		case 5:
			switch(event->type) {
				case  KeyPress:
				case  KeyRelease:
				case  ButtonPress:
				case  ButtonRelease:
				case  MotionNotify:
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xkey.subwindow);
					break;
				default:
					break;
			}
			break;
		case 6:
			switch(event->type) {
				case  KeyPress:
				case  KeyRelease:
				case  ButtonPress:
				case  ButtonRelease:
				case  MotionNotify:
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xkey.time);
					break;
				case  PropertyNotify:
					sv_setiv(ST(0), event->xproperty.time);
					break;
				case  SelectionClear:
					sv_setiv(ST(0), event->xselectionclear.time);
					break;
				case  SelectionRequest:
					sv_setiv(ST(0), event->xselectionrequest.time);
					break;
				case  SelectionNotify:
					sv_setiv(ST(0), event->xselection.time);
					break;
				default:
					break;
			}
			break;
		case 7:
			switch(event->type) {
				case  KeyPress:
				case  KeyRelease:
				case  ButtonPress:
				case  ButtonRelease:
				case  MotionNotify:
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xkey.x);
					break;
				case  Expose:
				case  GraphicsExpose:
					sv_setiv(ST(0), event->xexpose.x);
					break;
				case  CreateNotify:
				case  ConfigureNotify:
				case  ConfigureRequest:
				case  GravityNotify:
					sv_setiv(ST(0), event->xcreatewindow.x);
					break;
				case  ReparentNotify:
					sv_setiv(ST(0), event->xreparent.x);
					break;
				default:
					break;
			}
			break;
		case 8:
			switch(event->type) {
				case  KeyPress:
				case  KeyRelease:
				case  ButtonPress:
				case  ButtonRelease:
				case  MotionNotify:
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xkey.y);
					break;
				case  Expose:
				case  GraphicsExpose:
					sv_setiv(ST(0), event->xexpose.y);
					break;
				case  CreateNotify:
				case  ConfigureNotify:
				case  ConfigureRequest:
				case  GravityNotify:
					sv_setiv(ST(0), event->xcreatewindow.y);
					break;
				case  ReparentNotify:
					sv_setiv(ST(0), event->xreparent.y);
					break;
				default:
					break;
			}
			break;
		case 9:
			switch(event->type) {
				case  KeyPress:
				case  KeyRelease:
				case  ButtonPress:
				case  ButtonRelease:
				case  MotionNotify:
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xkey.x_root);
					break;
				default:
					break;
			}
			break;
		case 10:
			switch(event->type) {
				case  KeyPress:
				case  KeyRelease:
				case  ButtonPress:
				case  ButtonRelease:
				case  MotionNotify:
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xkey.y_root);
					break;
				default:
					break;
			}
			break;
		case 11:
			switch(event->type) {
				case  KeyPress:
				case  KeyRelease:
				case  ButtonPress:
				case  ButtonRelease:
				case  MotionNotify:
					sv_setiv(ST(0), event->xkey.state);
					break;
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xcrossing.state);
					break;
				case  VisibilityNotify:
					sv_setiv(ST(0), event->xvisibility.state);
					break;
				case  PropertyNotify:
					sv_setiv(ST(0), event->xproperty.state);
					break;
				case  ColormapNotify:
					sv_setiv(ST(0), event->xcolormap.state);
					break;
				default:
					break;
			}
			break;
		case 12:
			switch(event->type) {
				case  KeyPress:
				case  KeyRelease:
					sv_setiv(ST(0), event->xkey.keycode);
					break;
				default:
					break;
			}
			break;
		case 13:
			switch(event->type) {
				case  ButtonPress:
				case  ButtonRelease:
					sv_setiv(ST(0), event->xbutton.button);
					break;
				default:
					break;
			}
			break;
		case 14:
			switch(event->type) {
				case  MotionNotify:
					sv_setpvn(ST(0), &event->xmotion.is_hint, 1);
					break;
				default:
					break;
			}
			break;
		case 15:
			switch(event->type) {
				case  KeyPress:
				case  KeyRelease:
				case  ButtonPress:
				case  ButtonRelease:
					sv_setiv(ST(0), event->xkey.same_screen);
					break;
				case  MotionNotify:
					sv_setiv(ST(0), event->xmotion.same_screen);
					break;
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xcrossing.same_screen);
					break;
				default:
					break;
			}
			break;
		case 16:
			switch(event->type) {
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xcrossing.mode);
					break;
				case  FocusIn:
				case  FocusOut:
					sv_setiv(ST(0), event->xfocus.mode);
					break;
				default:
					break;
			}
			break;
		case 17:
			switch(event->type) {
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xcrossing.detail);
					break;
				case  FocusIn:
				case  FocusOut:
					sv_setiv(ST(0), event->xfocus.detail);
					break;
				case  ConfigureRequest:
					sv_setiv(ST(0), event->xconfigurerequest.detail);
					break;
				default:
					break;
			}
			break;
		case 18:
			switch(event->type) {
				case  EnterNotify:
				case  LeaveNotify:
					sv_setiv(ST(0), event->xcrossing.focus);
					break;
				default:
					break;
			}
			break;
		case 19:
			switch(event->type) {
				case  KeymapNotify:
					sv_setpvn(ST(0), event->xkeymap.key_vector, 32);
					break;
				default:
					break;
			}
			break;
		case 20:
			switch(event->type) {
				case  Expose:
				case  GraphicsExpose:
					sv_setiv(ST(0), event->xexpose.width);
					break;
				case  CreateNotify:
					sv_setiv(ST(0), event->xcreatewindow.width);
					break;
				case  ConfigureNotify:
				case  ConfigureRequest:
					sv_setiv(ST(0), event->xconfigure.width);
					break;
				case  ResizeRequest:
					sv_setiv(ST(0), event->xresizerequest.width);
					break;
				default:
					break;
			}
			break;
		case 21:
			switch(event->type) {
				case  Expose:
				case  GraphicsExpose:
					sv_setiv(ST(0), event->xexpose.height);
					break;
				case  CreateNotify:
					sv_setiv(ST(0), event->xcreatewindow.height);
					break;
				case  ConfigureNotify:
				case  ConfigureRequest:
					sv_setiv(ST(0), event->xconfigure.height);
					break;
				case  ResizeRequest:
					sv_setiv(ST(0), event->xresizerequest.height);
					break;
				default:
					break;
			}
			break;
		case 22:
			switch(event->type) {
				case  Expose :
				case  GraphicsExpose:
					sv_setiv(ST(0), event->xexpose.count);
					break;
				case  MappingNotify:
					sv_setiv(ST(0), event->xmapping.count);
					break;
				default:
					break;
			}
			break;
		case 23:
			switch(event->type) {
				case  GraphicsExpose:
				case  NoExpose:
					sv_setiv(ST(0), event->xgraphicsexpose.drawable);
					break;
				default:
					break;
			}
			break;
		case 24:
			switch(event->type) {
				case  GraphicsExpose:
					sv_setiv(ST(0), event->xgraphicsexpose.major_code);
					break;
				case  NoExpose:
					sv_setiv(ST(0), event->xnoexpose.major_code);
					break;
				default:
					break;
			}
			break;
		case 25:
			switch(event->type) {
				case  0:
					sv_setpvn(ST(0), (char *)&event->xerror.minor_code, 1);
					break;
				case  GraphicsExpose:
					sv_setiv(ST(0), event->xgraphicsexpose.minor_code);
					break;
				case  NoExpose:
					sv_setiv(ST(0), event->xnoexpose.minor_code);
					break;
				default:
					break;
			}
			break;
		case 26:
			switch(event->type) {
				case  CreateNotify:
				case  ConfigureRequest:
				case  CirculateRequest:
					sv_setiv(ST(0), event->xcreatewindow.parent);
					break;
				case  MapRequest:
					sv_setiv(ST(0), event->xmaprequest.parent);
					break;
				case  ReparentNotify:
					sv_setiv(ST(0), event->xreparent.parent);
					break;
				default:
					break;
			}
			break;
		case 27:
			switch(event->type) {
				case  DestroyNotify:
				case  UnmapNotify:
				case  MapNotify:
				case  ReparentNotify:
				case  ConfigureNotify:
				case  GravityNotify:
				case  CirculateNotify:
					sv_setiv(ST(0), event->xdestroywindow.event);
					break;
				default:
					break;
			}
			break;
		case 28:
			switch(event->type) {
				case  CreateNotify:
				case  ConfigureNotify:
				case  ConfigureRequest:
					sv_setiv(ST(0), event->xcreatewindow.border_width);
					break;
				default:
					break;
			}
			break;
		case 29:
			switch(event->type) {
				case  CreateNotify:
					sv_setiv(ST(0), event->xcreatewindow.override_redirect);
					break;
				case  ConfigureNotify:
					sv_setiv(ST(0), event->xconfigure.override_redirect);
					break;
				case  MapNotify:
					sv_setiv(ST(0), event->xmap.override_redirect);
					break;
				case  ReparentNotify:
					sv_setiv(ST(0), event->xreparent.override_redirect);
					break;
				default:
					break;
			}
			break;
		case 30:
			switch(event->type) {
				case  UnmapNotify:
					sv_setiv(ST(0), event->xunmap.from_configure);
					break;
				default:
					break;
			}
			break;
		case 31:
			switch(event->type) {
				case  ConfigureNotify:
				case  ConfigureRequest:
					sv_setiv(ST(0), event->xconfigure.above);
					break;
				default:
					break;
			}
			break;
		case 32:
			switch(event->type) {
				case  ConfigureRequest:
					sv_setiv(ST(0), event->xconfigurerequest.value_mask);
					break;
				default:
					break;
			}
			break;
		case 33:
			switch(event->type) {
				case  CirculateNotify:
				case  CirculateRequest:
					sv_setiv(ST(0), event->xcirculate.place);
					break;
				default:
					break;
			}
			break;
		case 34:
			switch(event->type) {
				case  PropertyNotify:
					sv_setiv(ST(0), event->xproperty.atom);
					break;
				default:
					break;
			}
			break;
		case 35:
			switch(event->type) {
				case  SelectionClear:
					sv_setiv(ST(0), event->xselectionclear.selection);
					break;
				case  SelectionRequest:
					sv_setiv(ST(0), event->xselectionrequest.selection);
					break;
				case  SelectionNotify:
					sv_setiv(ST(0), event->xselection.selection);
					break;
				default:
					break;
			}
			break;
		case 36:
			switch(event->type) {
				case  SelectionRequest:
					sv_setiv(ST(0), event->xselectionrequest.owner);
					break;
				default:
					break;
			}
			break;
		case 37:
			switch(event->type) {
				case  SelectionRequest:
					sv_setiv(ST(0), event->xselectionrequest.target);
					break;
				case  SelectionNotify:
					sv_setiv(ST(0), event->xselection.target);
					break;
				default:
					break;
			}
			break;
		case 38:
			switch(event->type) {
				case  SelectionRequest:
					sv_setiv(ST(0), event->xselectionrequest.property);
					break;
				case  SelectionNotify:
					sv_setiv(ST(0), event->xselection.property);
					break;
				default:
					break;
			}
			break;
		case 39:
			switch(event->type) {
				case  ColormapNotify:
					sv_setiv(ST(0), event->xcolormap.colormap);
					break;
				default:
					break;
			}
			break;
		case 40:
			switch(event->type) {
				case  ColormapNotify:
					sv_setiv(ST(0), event->xcolormap.new);
					break;
				default:
					break;
			}
			break;
		case 41:
			switch(event->type) {
				case  ClientMessage:
					sv_setiv(ST(0), event->xclient.message_type);
					break;
				default:
					break;
			}
			break;
		case 42:
			switch(event->type) {
				case  ClientMessage:
					sv_setiv(ST(0), event->xclient.format);
					break;
				default:
					break;
			}
			break;
		case 43:
			switch(event->type) {
				case  ClientMessage:
					sv_setpvn(ST(0), event->xclient.data.b, 20);
					break;
				default:
					break;
			}
			break;
		case 44:
			switch(event->type) {
				case  ClientMessage:
					sv_setiv(ST(0), event->xmapping.request);
					break;
				default:
					break;
			}
			break;
		case 45:
			switch(event->type) {
				case  ClientMessage:
					sv_setiv(ST(0), event->xmapping.first_keycode);
					break;
				default:
					break;
			}
			break;
		case 46:
			switch(event->type) {
				case  0:
					sv_setiv(ST(0), event->xerror.resourceid);
					break;
				default:
					break;
			}
			break;
		case 47:
			switch(event->type) {
				case  0:
					sv_setpvn(ST(0), (char *)&event->xerror.error_code, 1);
					break;
				default:
					break;
			}
			break;
		case 48:
			switch(event->type) {
				case  0:
					sv_setpvn(ST(0), (char *)&event->xerror.request_code, 1);
					break;
				default:
					break;
			}
			break;
		}
	}
#line 1040 "XEvent.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_X11__XEvent); /* prototype to pass -Wmissing-prototypes */
XS(boot_X11__XEvent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        newXS("X11::XEvent::constant", XS_X11__XEvent_constant, file);
        newXS("X11::XEvent::XKeycodeToKeysym", XS_X11__XEvent_XKeycodeToKeysym, file);
        newXS("X11::XEvent::new", XS_X11__XEvent_new, file);
        newXS("X11::XEvent::display", XS_X11__XEvent_display, file);
        cv = newXS("X11::XEvent::parent", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 26 ;
        cv = newXS("X11::XEvent::keycode", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 12 ;
        cv = newXS("X11::XEvent::atom", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 34 ;
        cv = newXS("X11::XEvent::event", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 27 ;
        cv = newXS("X11::XEvent::is_hint", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 14 ;
        cv = newXS("X11::XEvent::resourceid", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 46 ;
        cv = newXS("X11::XEvent::y_root", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 10 ;
        cv = newXS("X11::XEvent::type", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("X11::XEvent::key_vector", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 19 ;
        cv = newXS("X11::XEvent::data", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 43 ;
        cv = newXS("X11::XEvent::y", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("X11::XEvent::focus", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 18 ;
        cv = newXS("X11::XEvent::height", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 21 ;
        cv = newXS("X11::XEvent::value_mask", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 32 ;
        cv = newXS("X11::XEvent::same_screen", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 15 ;
        cv = newXS("X11::XEvent::request", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 44 ;
        cv = newXS("X11::XEvent::selection", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 35 ;
        cv = newXS("X11::XEvent::request_code", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 48 ;
        cv = newXS("X11::XEvent::count", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 22 ;
        cv = newXS("X11::XEvent::state", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 11 ;
        cv = newXS("X11::XEvent::send_event", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("X11::XEvent::error_code", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 47 ;
        cv = newXS("X11::XEvent::time", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("X11::XEvent::from_configure", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 30 ;
        cv = newXS("X11::XEvent::target", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 37 ;
        cv = newXS("X11::XEvent::button", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 13 ;
        cv = newXS("X11::XEvent::minor_code", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 25 ;
        cv = newXS("X11::XEvent::serial", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("X11::XEvent::colormap", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 39 ;
        cv = newXS("X11::XEvent::place", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 33 ;
        cv = newXS("X11::XEvent::drawable", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 23 ;
        cv = newXS("X11::XEvent::subwindow", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 5 ;
        cv = newXS("X11::XEvent::root", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 4 ;
        cv = newXS("X11::XEvent::format", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 42 ;
        cv = newXS("X11::XEvent::window", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 3 ;
        cv = newXS("X11::XEvent::major_code", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 24 ;
        cv = newXS("X11::XEvent::above", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 31 ;
        cv = newXS("X11::XEvent::first_keycode", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 45 ;
        cv = newXS("X11::XEvent::c_new", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 40 ;
        cv = newXS("X11::XEvent::property", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 38 ;
        cv = newXS("X11::XEvent::mode", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 16 ;
        cv = newXS("X11::XEvent::owner", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 36 ;
        cv = newXS("X11::XEvent::width", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 20 ;
        cv = newXS("X11::XEvent::message_type", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 41 ;
        cv = newXS("X11::XEvent::detail", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 17 ;
        cv = newXS("X11::XEvent::border_width", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 28 ;
        cv = newXS("X11::XEvent::x_root", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 9 ;
        cv = newXS("X11::XEvent::x", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 7 ;
        cv = newXS("X11::XEvent::override_redirect", XS_X11__XEvent_type, file);
        XSANY.any_i32 = 29 ;
    }
    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

